<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/common/logger.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/common/logger.py" />
              <option name="originalContent" value="import logging&#10;import functools&#10;from datetime import datetime&#10;from queue import Queue&#10;from PySide6.QtCore import QObject, Signal&#10;&#10;&#10;class ColouredConsoleHandler(logging.StreamHandler):&#10;    &quot;&quot;&quot;Custom handler to add colours to console output.&quot;&quot;&quot;&#10;    COLORS = {&#10;        &quot;DEBUG&quot;: &quot;\033[37m&quot;,     # White / Light gray&#10;        &quot;INFO&quot;: &quot;\033[36m&quot;,      # Cyan&#10;        &quot;WARNING&quot;: &quot;\033[33m&quot;,   # Yellow&#10;        &quot;ERROR&quot;: &quot;\033[31m&quot;,     # Red&#10;        &quot;CRITICAL&quot;: &quot;\033[95m&quot;,  # Bright Magenta&#10;        &quot;RESET&quot;: &quot;\033[0m&quot;,&#10;    }&#10;&#10;    def format(self, record):&#10;        base = super().format(record)&#10;        color = self.COLORS.get(record.levelname, &quot;&quot;)&#10;        reset = self.COLORS[&quot;RESET&quot;]&#10;        return f&quot;{color}{base}{reset}&quot;&#10;&#10;&#10;class Logger(QObject):&#10;    &quot;&quot;&quot;Singleton Qt Logger with queue-based storage, coloured console output, and export feature.&quot;&quot;&quot;&#10;    _instance = None&#10;    log_updated = Signal(str)  # Qt signal emitted when a new log entry is added&#10;&#10;    def __new__(cls, *args, **kwargs):&#10;        if cls._instance is None:&#10;            cls._instance = super().__new__(cls)&#10;        return cls._instance&#10;&#10;    def __init__(self, name: str = &quot;Application&quot;, level=logging.DEBUG):&#10;        if getattr(self, &quot;_initialized&quot;, False):&#10;            return&#10;&#10;        super().__init__()&#10;        self.name = name&#10;        self.level = level&#10;        self.logs = Queue()&#10;&#10;        # Python logging setup&#10;        self._logger = logging.getLogger(name)&#10;        self._logger.setLevel(level)&#10;        self._logger.propagate = False&#10;&#10;        console_handler = ColouredConsoleHandler()&#10;        console_handler.setLevel(level)&#10;        formatter = logging.Formatter(&#10;            &quot;%(asctime)s | %(levelname)s | %(name)s | %(message)s&quot;&#10;        )&#10;        console_handler.setFormatter(formatter)&#10;&#10;        if not self._logger.handlers:&#10;            self._logger.addHandler(console_handler)&#10;&#10;        self._initialized = True&#10;&#10;    def _store_log(self, level_name: str, msg: str):&#10;        &quot;&quot;&quot;Store log in queue and emit update signal.&quot;&quot;&quot;&#10;        timestamp = datetime.now().strftime(&quot;%d-%m-%Y %H:%M:%S&quot;)&#10;        formatted = f&quot;{timestamp} | {level_name} | {msg}&quot;&#10;        self.logs.put(formatted)&#10;&#10;        self.log_updated.emit(formatted)&#10;        return formatted&#10;&#10;    # Public logging API (unchanged)&#10;    def debug(self, msg, *args, **kwargs):&#10;        formatted = self._store_log(&quot;DEBUG&quot;, msg)&#10;        self._logger.debug(msg, *args, **kwargs)&#10;        return formatted&#10;&#10;    def info(self, msg, *args, **kwargs):&#10;        formatted = self._store_log(&quot;INFO&quot;, msg)&#10;        self._logger.info(msg, *args, **kwargs)&#10;        return formatted&#10;&#10;    def warning(self, msg, *args, **kwargs):&#10;        formatted = self._store_log(&quot;WARNING&quot;, msg)&#10;        self._logger.warning(msg, *args, **kwargs)&#10;        return formatted&#10;&#10;    def error(self, msg, *args, **kwargs):&#10;        formatted = self._store_log(&quot;ERROR&quot;, msg)&#10;        self._logger.error(msg, *args, **kwargs)&#10;        return formatted&#10;&#10;    def critical(self, msg, *args, **kwargs):&#10;        formatted = self._store_log(&quot;CRITICAL&quot;, msg)&#10;        self._logger.critical(msg, *args, **kwargs)&#10;        return formatted&#10;&#10;    def log_function(self, level=logging.DEBUG):&#10;        def decorator(func):&#10;            @functools.wraps(func)&#10;            def wrapper(*args, **kwargs):&#10;                if self._logger.isEnabledFor(level):&#10;                    arg_list = [repr(a) for a in args] + [f&quot;{k}={v!r}&quot; for k, v in kwargs.items()]&#10;                    call_msg = f&quot;Calling {func.__name__}({', '.join(arg_list)})&quot;&#10;                    self.debug(call_msg)&#10;                result = func(*args, **kwargs)&#10;                if self._logger.isEnabledFor(level):&#10;                    self.debug(f&quot;{func.__name__} returned {result!r}&quot;)&#10;                return result&#10;            return wrapper&#10;&#10;        return decorator&#10;&#10;    def export_to_file(self, file_path: str):&#10;        items = list(self.logs.queue)&#10;        with open(file_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:&#10;            for line in items:&#10;                f.write(line + &quot;\n&quot;)&#10;" />
              <option name="updatedContent" value="import logging&#10;import functools&#10;from datetime import datetime&#10;from queue import Queue&#10;from PySide6.QtCore import QObject, Signal&#10;&#10;&#10;class ColouredConsoleHandler(logging.StreamHandler):&#10;    &quot;&quot;&quot;Custom handler to add colours to console output.&quot;&quot;&quot;&#10;    COLORS = {&#10;        &quot;DEBUG&quot;: &quot;\033[37m&quot;,     # White / Light gray&#10;        &quot;INFO&quot;: &quot;\033[36m&quot;,      # Cyan&#10;        &quot;WARNING&quot;: &quot;\033[33m&quot;,   # Yellow&#10;        &quot;ERROR&quot;: &quot;\033[31m&quot;,     # Red&#10;        &quot;CRITICAL&quot;: &quot;\033[95m&quot;,  # Bright Magenta&#10;        &quot;RESET&quot;: &quot;\033[0m&quot;,&#10;    }&#10;&#10;    def format(self, record):&#10;        base = super().format(record)&#10;        color = self.COLORS.get(record.levelname, &quot;&quot;)&#10;        reset = self.COLORS[&quot;RESET&quot;]&#10;        return f&quot;{color}{base}{reset}&quot;&#10;&#10;&#10;class Logger(QObject):&#10;    &quot;&quot;&quot;Singleton Qt Logger with queue-based storage, coloured console output, and export feature.&quot;&quot;&quot;&#10;    _instance = None&#10;    log_updated = Signal(str)  # Qt signal emitted when a new log entry is added&#10;&#10;    def __new__(cls, *args, **kwargs):&#10;        if cls._instance is None:&#10;            cls._instance = super().__new__(cls)&#10;        return cls._instance&#10;&#10;    def __init__(self, name: str = &quot;Application&quot;, level=logging.DEBUG):&#10;        if getattr(self, &quot;_initialized&quot;, False):&#10;            return&#10;&#10;        super().__init__()&#10;        self.name = name&#10;        self.logs = Queue()&#10;&#10;        # Python logging setup&#10;        self._logger = logging.getLogger(name)&#10;        self._logger.propagate = False&#10;&#10;        console_handler = ColouredConsoleHandler()&#10;        formatter = logging.Formatter(&#10;            &quot;%(asctime)s | %(levelname)s | %(name)s | %(message)s&quot;&#10;        )&#10;        console_handler.setFormatter(formatter)&#10;&#10;        if not self._logger.handlers:&#10;            self._logger.addHandler(console_handler)&#10;&#10;        self.set_level(level)&#10;        self._initialized = True&#10;&#10;    def set_level(self, level):&#10;        &quot;&quot;&quot;Sets the logging level for the logger and its handlers.&quot;&quot;&quot;&#10;        self.level = level&#10;        self._logger.setLevel(level)&#10;        for handler in self._logger.handlers:&#10;            handler.setLevel(level)&#10;&#10;    def _store_log(self, level_name: str, msg: str):&#10;        &quot;&quot;&quot;Store log in queue and emit update signal.&quot;&quot;&quot;&#10;        timestamp = datetime.now().strftime(&quot;%d-%m-%Y %H:%M:%S&quot;)&#10;        formatted = f&quot;{timestamp} | {level_name} | {msg}&quot;&#10;        self.logs.put(formatted)&#10;&#10;        self.log_updated.emit(formatted)&#10;        return formatted&#10;&#10;    # Public logging API (unchanged)&#10;    def debug(self, msg, *args, **kwargs):&#10;        formatted = self._store_log(&quot;DEBUG&quot;, msg)&#10;        self._logger.debug(msg, *args, **kwargs)&#10;        return formatted&#10;&#10;    def info(self, msg, *args, **kwargs):&#10;        formatted = self._store_log(&quot;INFO&quot;, msg)&#10;        self._logger.info(msg, *args, **kwargs)&#10;        return formatted&#10;&#10;    def warning(self, msg, *args, **kwargs):&#10;        formatted = self._store_log(&quot;WARNING&quot;, msg)&#10;        self._logger.warning(msg, *args, **kwargs)&#10;        return formatted&#10;&#10;    def error(self, msg, *args, **kwargs):&#10;        formatted = self._store_log(&quot;ERROR&quot;, msg)&#10;        self._logger.error(msg, *args, **kwargs)&#10;        return formatted&#10;&#10;    def critical(self, msg, *args, **kwargs):&#10;        formatted = self._store_log(&quot;CRITICAL&quot;, msg)&#10;        self._logger.critical(msg, *args, **kwargs)&#10;        return formatted&#10;&#10;    def log_function(self, level=logging.DEBUG):&#10;        def decorator(func):&#10;            @functools.wraps(func)&#10;            def wrapper(*args, **kwargs):&#10;                if self._logger.isEnabledFor(level):&#10;                    arg_list = [repr(a) for a in args] + [f&quot;{k}={v!r}&quot; for k, v in kwargs.items()]&#10;                    call_msg = f&quot;Calling {func.__name__}({', '.join(arg_list)})&quot;&#10;                    self.debug(call_msg)&#10;                result = func(*args, **kwargs)&#10;                if self._logger.isEnabledFor(level):&#10;                    self.debug(f&quot;{func.__name__} returned {result!r}&quot;)&#10;                return result&#10;            return wrapper&#10;&#10;        return decorator&#10;&#10;    def export_to_file(self, file_path: str):&#10;        items = list(self.logs.queue)&#10;        with open(file_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:&#10;            for line in items:&#10;                f.write(line + &quot;\n&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>